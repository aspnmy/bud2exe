#!/bin/bash
# 编译脚本成二进制文件
#   "name": "bud2exe",
#   "version": "1.0.0",
#   "description": "一个sh脚本编译工具,可以编译脚本成bin或exe文件,暂时不支持MacOS,可绕过杀软,请不要编译非法代码.Tg讨论组:https://t.me/+BqvlH6BDOWE3NjQ1,赞助我们:TKqTUNcBWiRDdczuHoQstMD4XRyFgNwHiF (TRX/USDT)\",
#   "main": "Src/bud2exe",
#   "author": "aspnmy@gmail.com",
#   "license": "ISC",
#   "bugs": {
#     "url": "https://github.com/aspnmy/bud2exe/issues"
#   },
#   "homepage": "https://github.com/aspnmy/bud2exe#readme"
#   "用法":"bud2exe -s <b2bin|b2GCC|b2WIN> -o output_file -f input_file "
# 以传参的形式执行的脚本



# 读取版本号
bud_ver=$(cat "./newVer.bud")
if [ -z "$bud_ver" ]; then
    echo "Error: Version file './newVer.bud' is empty or found."
    exit 1
fi
# 定义版本号
VERSION=$bud_ver
echo "Version: $VERSION"

# 函数声明
b2bin() {
    local output_file="$1"
    local input_file="$2"
    # 静态编译
    CLAGS="-static" shc  -r -f "$input_file" -o "$output_file'_v'$bud_ver"
    if [ $? -eq 0 ]; then
        echo "脚本编译成功,保存在$output_file'_v'$bud_ver"
    else
        echo "脚本编译失败."
        exit 1
    fi
}

b2GCC() {
    local output_file="$1"
    local input_file="$2"

    # shc静态编译
    CLAGS="-static" shc  -r -f "$input_file" -o "$output_file"
    
    # gcc 再打包一层壳 静态编译
    gcc -static -o $output_file'_v'$bud_ver "$input_file.x.c" -DVERSION="$bud_ver"
    if [ $? -eq 0 ]; then
        rm $output_file
        echo "脚本编译成功,保存在$output_file'_v'$bud_ver"
    else
        echo "脚本编译失败."
        exit 1
    fi
}

b2WIN() {
    # todo: 需要解决/bin/bash 在win中不支持问题
    # local output_file="$1"
    # local input_file="$2"
    # local bud_ver="$3"

    # # 静态编译
    # CLAGS="-static" shc  -r -f "$input_file" -o "$output_file"
    # if [ $? -ne 0 ]; then
    #     echo "Error: shc compilation failed."
    #     exit 1
    # fi

    # # 使用 MinGW-w64 静态编译 交叉编译器编译 C 文件
    # x86_64-w64-mingw32-gcc -static -DVERSION="$bud_ver" -o "b2WIN.exe" "$input_file.x.c"
    # if [ $? -ne 0 ]; then
    #     echo "Error: x86_64-w64-mingw32-gcc compilation failed."
    #     exit 1
    # fi

    # echo "脚本编译成功,保存在'b2WIN.exe'"
     echo "正在开发中,敬请期待'"
}

help() {
    echo "poetryBeBe poetry哔哔小子,一个简单的poetry管理工具-免费版"
    echo "Tg讨论组:https://t.me/+BqvlH6BDOWE3NjQ1"
    echo "赞助我们:TKqTUNcBWiRDdczuHoQstMD4XRyFgNwHiF (TRX/USDT)"
    echo "1)b2bin/编译脚本成为一个1层加壳的二进制文件(需要shc组件)/用法: bud2exe -s b2bin -o output_file -f input_file "
    echo "2)b2GCC/用GCC再次编译脚本成为一个2层加壳的二进制文件(需要gcc组件)/用法: bud2exe -s b2GCC -o output_file -f input_file "
    echo "3)b2WIN/编译脚本成为一个64位exe文件(需要安装MinGW-w64 交叉编译工具链)/用法: bud2exe -s b2WIN -o output_file -f input_file "
    echo "0)退出"
}

# 解析命令行选项
while getopts "s:o:f:h" opt; do
    case "${opt}" in
        s)
            sub_command="${OPTARG}"
            ;;
        o)
            output_file="${OPTARG}"
            ;;
        f)
            input_file="${OPTARG}"
            ;;
        h)
            help
            exit 0
            ;;
        *)
            echo "Usage: bud2exe -s <b2bin|b2GCC|b2WIN> -o output_file -f input_file "
            exit 1
            ;;
    esac
done

# 检查是否提供了所有必需的参数
if [ -z "${output_file}" ] || [ -z "${input_file}" ] || [ -z "${sub_command}" ]; then
    echo "Error: All options must be provided."
    echo "Usage: bud2exe -s <b2bin|b2GCC|b2WIN> -o output_file -f input_file "
    exit 1
fi



# 根据子命令执行相应的函数
case "${sub_command}" in
    b2bin)
        b2bin "${output_file}" "${input_file}"
        ;;
    b2GCC)
        b2GCC "${output_file}" "${input_file}"
        ;;
    b2WIN)
        b2WIN "${output_file}" "${input_file}" 
        ;;
    help)
        help
        ;;
    *)
        echo "Invalid sub-command: ${sub_command}"
        echo "Usage: bud2exe -s <b2bin|b2GCC|b2WIN> -o output_file -f input_file "
        help
        exit 1
        ;;
esac
